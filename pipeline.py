"""Core audio -> score pipeline for BTT MVP."""

from __future__ import annotations

import glob
import shlex
import subprocess
import warnings
from pathlib import Path

from pydub import AudioSegment

from config import (
    DEMUCS_MODEL,
    DOWNLOADS_DIR,
    INSTRUMENT_SPECS,
    MUSESCORE_CMD,
    OUTPUT_DIR,
    TEMP_DIR,
    YOUTUBE_DOMAINS,
)
from utils import (
    classify_audio_source,
    create_disclaimer_text,
    sanitize_filename,
    validate_single_video_youtube_url,
)


def _run(cmd: list[str]) -> None:
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        rendered = " ".join(shlex.quote(part) for part in cmd)
        raise RuntimeError(
            f"Command failed ({result.returncode}): {rendered}\n{result.stderr.strip()}"
        )


def _ensure_dirs() -> None:
    TEMP_DIR.mkdir(parents=True, exist_ok=True)
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    DOWNLOADS_DIR.mkdir(parents=True, exist_ok=True)


def download_or_convert_audio(source: str, run_dir: Path | None = None) -> str:
    """Convert local audio file or YouTube URL into normalized wav."""
    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    workdir.mkdir(parents=True, exist_ok=True)
    source = source.strip()
    output_wav = workdir / "input_normalized.wav"
    source_kind = classify_audio_source(source, YOUTUBE_DOMAINS)

    if source_kind == "youtube_url":
        youtube_error = validate_single_video_youtube_url(source, YOUTUBE_DOMAINS)
        if youtube_error:
            raise ValueError(youtube_error)
        yt_template = str(workdir / "youtube_input.%(ext)s")
        _run(
            [
                "yt-dlp",
                "--no-playlist",
                "-x",
                "--audio-format",
                "wav",
                "-o",
                yt_template,
                source,
            ]
        )
        yt_files = sorted(glob.glob(str(workdir / "youtube_input.*")))
        if not yt_files:
            raise RuntimeError("yt-dlp did not produce an audio file.")
        audio = AudioSegment.from_file(yt_files[0])
    else:
        if source_kind == "remote_url":
            raise ValueError("Only single-video YouTube URLs are supported for remote input.")
        input_path = Path(source)
        if not input_path.exists():
            raise FileNotFoundError(f"Audio source does not exist: {source}")
        audio = AudioSegment.from_file(str(input_path))

    audio = audio.set_channels(2).set_frame_rate(44100)
    audio.export(str(output_wav), format="wav")
    return str(output_wav)


def separate_stems(wav_path: str, run_dir: Path | None = None) -> dict[str, str]:
    """Run Demucs separation and return stem-name -> wav path."""
    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    wav = Path(wav_path)
    if not wav.exists():
        raise FileNotFoundError(f"Input wav missing: {wav_path}")

    demucs_out = workdir / "demucs"
    _run(["demucs", "-n", DEMUCS_MODEL, "-o", str(demucs_out), str(wav)])

    stem_root = demucs_out / DEMUCS_MODEL / wav.stem
    if not stem_root.exists():
        raise RuntimeError(f"Demucs output folder missing: {stem_root}")

    stems: dict[str, str] = {}
    for stem_file in sorted(stem_root.glob("*.wav")):
        stems[stem_file.stem] = str(stem_file)
    if not stems:
        raise RuntimeError("No stems were generated by Demucs.")
    return stems


def transcribe_to_midi(stems: dict[str, str], run_dir: Path | None = None) -> dict[str, str]:
    """Run basic-pitch CLI on each stem file and return stem-name -> midi path."""
    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    midi_root = workdir / "midi"
    midi_root.mkdir(parents=True, exist_ok=True)

    outputs: dict[str, str] = {}
    for stem_name, stem_path in stems.items():
        stem_dir = midi_root / sanitize_filename(stem_name)
        stem_dir.mkdir(parents=True, exist_ok=True)
        _run(["basic-pitch", str(stem_dir), str(stem_path)])
        midi_candidates = sorted(stem_dir.glob("*.mid")) + sorted(stem_dir.glob("*.midi"))
        if not midi_candidates:
            raise RuntimeError(f"No MIDI produced for stem: {stem_name}")
        outputs[stem_name] = str(midi_candidates[0])
    return outputs


def _grid_to_divisor(grid: str) -> int:
    mapping = {"1/4": 1, "1/8": 2, "1/16": 4}
    return mapping.get(grid, 2)


def _suppress_known_music21_warnings() -> None:
    """Mute noisy non-fatal music21 warnings that clutter Streamlit logs."""
    try:
        from music21 import beam

        beam.environLocal["warnings"] = 0
    except Exception:
        pass
    warnings.filterwarnings(
        "ignore",
        message=r"cannot access qLenPos .*",
        category=UserWarning,
    )
    warnings.filterwarnings(
        "ignore",
        message=r"Cannot put in an element with a missing voice tag .*",
        category=UserWarning,
    )


def _simplify_part(part_stream, options: dict) -> None:
    divisor = _grid_to_divisor(options.get("quantize_grid", "1/8"))
    min_duration = float(options.get("min_note_duration_beats", 0.25))
    density_threshold = int(options.get("density_threshold", 6))

    part_stream.quantize(
        quarterLengthDivisors=(divisor,),
        processOffsets=True,
        processDurations=True,
        inPlace=True,
        recurse=True,
    )

    # Work on stream-owned note/rest objects, not a flattened copy.
    # Removing elements from flattened views does not reliably mutate the source stream.
    flattened = part_stream.recurse()
    bucket_counts: dict[int, int] = {}
    for element in list(flattened.notesAndRests):
        if getattr(element, "isNote", False) or getattr(element, "isChord", False):
            if float(element.duration.quarterLength) < min_duration:
                if element.activeSite is not None:
                    element.activeSite.remove(element)
                continue
            bucket = int(float(element.getOffsetInHierarchy(part_stream)))
            bucket_counts[bucket] = bucket_counts.get(bucket, 0) + 1
            if bucket_counts[bucket] > density_threshold:
                if element.activeSite is not None:
                    element.activeSite.remove(element)


def _is_beginner_profile(options: dict) -> bool:
    profile = str(options.get("profile", "")).strip()
    return profile in {"Beginner", "Aggressive"}


def _iter_melodic_notes(part_stream):
    """Yield note-like elements in temporal order for melodic post-processing."""
    for element in part_stream.recurse().notes:
        if getattr(element, "isChord", False):
            yield element
        elif getattr(element, "isNote", False):
            yield element


def _primary_pitch_midi(element) -> int | None:
    if getattr(element, "isChord", False):
        pitches = list(getattr(element, "pitches", []) or [])
        if not pitches:
            return None
        return int(min(p.midi for p in pitches))
    if getattr(element, "isNote", False):
        pitch_obj = getattr(element, "pitch", None)
        if pitch_obj is None:
            return None
        return int(pitch_obj.midi)
    return None


def _set_element_to_midi(element, midi_value: int) -> None:
    from music21 import pitch

    new_pitch = pitch.Pitch()
    new_pitch.midi = int(midi_value)
    if getattr(element, "isChord", False):
        element.pitches = (new_pitch,)
    elif getattr(element, "isNote", False):
        element.pitch = new_pitch


def _nearest_scale_midi(target_midi: int, allowed_pitch_classes: set[int]) -> int:
    candidates: list[int] = []
    for delta in range(-2, 3):
        candidate = int(target_midi + delta)
        if candidate % 12 in allowed_pitch_classes:
            candidates.append(candidate)
    if not candidates:
        return target_midi
    return min(candidates, key=lambda value: abs(value - target_midi))


def _playability_metrics(part_stream) -> dict[str, float]:
    note_elements = list(_iter_melodic_notes(part_stream))
    midi_line = [value for value in (_primary_pitch_midi(n) for n in note_elements) if value is not None]
    note_count = len(note_elements)
    if note_count == 0:
        return {
            "note_count": 0.0,
            "accidental_density": 0.0,
            "large_leap_rate": 0.0,
            "short_note_rate": 0.0,
        }

    accidental_count = 0
    short_count = 0
    for element in note_elements:
        if float(element.duration.quarterLength) <= 0.5:
            short_count += 1
        if getattr(element, "isChord", False):
            pitches = list(getattr(element, "pitches", []) or [])
            accidental_count += sum(1 for p in pitches if p.accidental is not None)
        elif getattr(element, "isNote", False):
            pitch_obj = getattr(element, "pitch", None)
            if pitch_obj is not None and pitch_obj.accidental is not None:
                accidental_count += 1

    leaps = [abs(curr - prev) for prev, curr in zip(midi_line, midi_line[1:])]
    large_leap_count = sum(1 for size in leaps if size >= 8)

    return {
        "note_count": float(note_count),
        "accidental_density": float(accidental_count / note_count),
        "large_leap_rate": float(large_leap_count / max(1, len(leaps))),
        "short_note_rate": float(short_count / note_count),
    }


def _apply_beginner_melody_filter(part_stream) -> dict[str, float]:
    """Apply additional melody-aware cleanup for beginner readability."""
    from music21 import key

    notes = list(_iter_melodic_notes(part_stream))
    if not notes:
        return _playability_metrics(part_stream)

    # Remove very short ornament-like events.
    for element in list(notes):
        if float(element.duration.quarterLength) < 0.5 and element.activeSite is not None:
            element.activeSite.remove(element)

    notes = list(_iter_melodic_notes(part_stream))
    if not notes:
        return _playability_metrics(part_stream)

    # Favor diatonic pitches of the local key to reduce accidental noise.
    try:
        analyzed_key = part_stream.analyze("key")
    except Exception:
        analyzed_key = key.Key("C")
    allowed_pitch_classes = set(int(p.pitchClass) for p in analyzed_key.getScale().pitches)
    for element in notes:
        base = _primary_pitch_midi(element)
        if base is None:
            continue
        snapped = _nearest_scale_midi(base, allowed_pitch_classes)
        _set_element_to_midi(element, snapped)

    # Clamp leaps by octave-folding toward the previous pitch.
    notes = list(_iter_melodic_notes(part_stream))
    previous_midi: int | None = None
    for element in notes:
        current_midi = _primary_pitch_midi(element)
        if current_midi is None:
            continue
        if previous_midi is not None:
            while current_midi - previous_midi > 7:
                current_midi -= 12
            while previous_midi - current_midi > 7:
                current_midi += 12
            _set_element_to_midi(element, current_midi)
        previous_midi = current_midi

    return _playability_metrics(part_stream)


def assess_song_fit(midis: dict[str, str], assignment: dict[str, str]) -> dict:
    """Assess classroom fit from assigned melodic MIDI parts.

    Returns a dict with:
    - fit_score (0-100)
    - fit_label (Good Fit / Borderline / Poor Fit)
    - recommended_profile (Beginner / Easy Intermediate)
    - reasons (plain-language list)
    - part_metrics (per melodic part metrics)
    """
    from music21 import converter

    percussion_tokens = ("Snare", "Bass Drum", "Percussion", "Auxiliary", "Timpani")
    part_metrics: list[dict] = []

    for stem_name, midi_path in midis.items():
        instrument_name = str(assignment.get(stem_name, "") or "").strip()
        if not instrument_name:
            continue
        if any(token in instrument_name for token in percussion_tokens):
            continue
        midi_file = Path(midi_path)
        if not midi_file.exists():
            continue

        with warnings.catch_warnings():
            _suppress_known_music21_warnings()
            parsed = converter.parse(str(midi_file))
        part_stream = parsed.parts[0] if parsed.parts else parsed
        metrics = _playability_metrics(part_stream)
        metrics["name"] = instrument_name
        part_metrics.append(metrics)

    if not part_metrics:
        return {
            "fit_score": 25,
            "fit_label": "Poor Fit",
            "recommended_profile": "Beginner",
            "reasons": [
                "No clear melodic parts were detected from current assignments.",
                "Try different stem assignments or use a simpler song.",
            ],
            "part_metrics": [],
        }

    total_notes = sum(float(item["note_count"]) for item in part_metrics)
    if total_notes <= 0:
        total_notes = float(len(part_metrics))

    weighted_accidental = sum(
        float(item["accidental_density"]) * float(item["note_count"]) for item in part_metrics
    ) / total_notes
    weighted_leaps = sum(
        float(item["large_leap_rate"]) * float(item["note_count"]) for item in part_metrics
    ) / total_notes
    weighted_short = sum(
        float(item["short_note_rate"]) * float(item["note_count"]) for item in part_metrics
    ) / total_notes
    sparse_parts = sum(1 for item in part_metrics if float(item["note_count"]) < 24)
    sparse_rate = sparse_parts / max(1, len(part_metrics))

    penalty = (
        (weighted_accidental * 38.0)
        + (weighted_leaps * 32.0)
        + (weighted_short * 24.0)
        + (sparse_rate * 10.0)
    )
    fit_score = int(max(0, min(100, round(100.0 - penalty))))

    if fit_score >= 70:
        fit_label = "Good Fit"
    elif fit_score >= 45:
        fit_label = "Borderline"
    else:
        fit_label = "Poor Fit"

    if fit_label == "Good Fit":
        recommended_profile = "Easy Intermediate"
    else:
        recommended_profile = "Beginner"

    reasons: list[str] = []
    if weighted_short >= 0.45:
        reasons.append("Many fast notes were detected, which can be hard for younger players.")
    if weighted_accidental >= 0.25:
        reasons.append("The melody uses many sharps/flats, which may reduce readability.")
    if weighted_leaps >= 0.35:
        reasons.append("Large pitch jumps appear often, which can hurt playability.")
    if sparse_rate >= 0.5:
        reasons.append("Some parts are sparse/noisy and may need reassignment.")
    if not reasons:
        reasons.append("The current assignments look classroom-friendly for this level.")

    return {
        "fit_score": fit_score,
        "fit_label": fit_label,
        "recommended_profile": recommended_profile,
        "reasons": reasons,
        "part_metrics": part_metrics,
    }


def build_score(
    midis: dict[str, str], assignment: dict[str, str], options: dict,
    run_dir: Path | None = None,
) -> dict[str, str | dict[str, str]]:
    """Build concert-pitch full score and transposed individual part MusicXML files.

    Returns dict with keys:
        "full_score": path to concert-pitch MusicXML
        "parts": dict mapping part_name -> transposed part MusicXML path
    """
    import copy

    from music21 import clef, converter, expressions, instrument, interval, metadata, stream

    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    score = stream.Score(id="btt-score")
    score.metadata = metadata.Metadata()
    score.metadata.title = options.get("title", "Untitled")
    score.metadata.composer = options.get("composer", "")

    disclaimer = create_disclaimer_text(options.get("school", ""))
    simplify_enabled = bool(options.get("simplify_enabled", False))

    part_dir = workdir / "part_exports"
    part_dir.mkdir(parents=True, exist_ok=True)
    transposed_parts: dict[str, str] = {}
    skipped_parts: list[dict] = []
    instrument_counts: dict[str, int] = {}
    percussion_family_tokens = ("Snare", "Bass Drum", "Percussion", "Auxiliary")
    treble_family_tokens = (
        "Flute",
        "Oboe",
        "Clarinet",
        "Sax",
        "Trumpet",
        "Horn",
        "Mallets",
        "Timpani",
    )
    bass_family_tokens = ("Tuba", "Trombone", "Bassoon", "Euphonium")

    def _preferred_clef_for_instrument(name: str):
        if any(token in name for token in percussion_family_tokens):
            return clef.PercussionClef()
        if any(token in name for token in bass_family_tokens):
            return clef.BassClef()
        if any(token in name for token in treble_family_tokens):
            return clef.TrebleClef()
        return None

    def _apply_instrument_and_clef(part_obj, name: str) -> None:
        # MIDI imports may include many embedded instrument-change markers.
        # Normalize to exactly one instrument at offset 0 for clean engraving.
        for existing_instrument in list(part_obj.recurse().getElementsByClass(instrument.Instrument)):
            try:
                existing_instrument.activeSite.remove(existing_instrument)
            except Exception:
                pass
        try:
            part_obj.insert(0, instrument.fromString(name))
        except Exception:
            pass
        preferred = _preferred_clef_for_instrument(name)
        if preferred is not None:
            for existing in list(part_obj.recurse().getElementsByClass(clef.Clef)):
                try:
                    existing.activeSite.remove(existing)
                except Exception:
                    pass
            part_obj.insert(0, preferred)

    for stem_name, midi_path in midis.items():
        instrument_name = assignment.get(stem_name, "").strip()
        if not instrument_name:
            continue

        # Disambiguate when multiple stems share the same instrument
        instrument_counts[instrument_name] = instrument_counts.get(instrument_name, 0) + 1
        count = instrument_counts[instrument_name]
        part_label = instrument_name if count == 1 else f"{instrument_name} ({count})"

        parsed = converter.parse(midi_path)
        part_stream = parsed.parts[0] if parsed.parts else parsed
        part_stream.partName = part_label
        part_stream.partAbbreviation = part_label

        if simplify_enabled:
            _simplify_part(part_stream, options)
            if _is_beginner_profile(options) and not any(
                token in instrument_name for token in ("Snare", "Bass Drum", "Percussion")
            ):
                metrics = _apply_beginner_melody_filter(part_stream)
                if (
                    metrics["note_count"] > 0
                    and (
                        metrics["accidental_density"] > 0.35
                        or metrics["large_leap_rate"] > 0.45
                        or metrics["short_note_rate"] > 0.55
                    )
                ):
                    skipped_parts.append(
                        {
                            "name": part_label,
                            "status": "skipped",
                            "reason": "unplayable_beginner",
                            "note_count": 0,
                        }
                    )
                    continue

        # Concert-pitch copy for the full score
        concert_part = copy.deepcopy(part_stream)
        _apply_instrument_and_clef(concert_part, instrument_name)
        concert_part.insert(0, expressions.TextExpression(disclaimer))
        score.insert(0, concert_part)

        # Transposed copy for the individual part export
        semitones = int(INSTRUMENT_SPECS.get(instrument_name, 0))
        transposed_part = copy.deepcopy(part_stream)
        if semitones:
            transposed_part.transpose(interval.Interval(semitones), inPlace=True)
        _apply_instrument_and_clef(transposed_part, instrument_name)
        transposed_part.metadata = metadata.Metadata()
        transposed_part.metadata.title = options.get("title", "Untitled")
        transposed_part.metadata.composer = options.get("composer", "")
        transposed_part.insert(0, expressions.TextExpression(disclaimer))
        with warnings.catch_warnings():
            _suppress_known_music21_warnings()
            transposed_part = transposed_part.makeNotation(inPlace=False)

        part_xml = part_dir / f"{sanitize_filename(part_label)}.musicxml"
        transposed_part.write("musicxml", fp=str(part_xml))
        transposed_parts[part_label] = str(part_xml)

    if not score.parts:
        raise RuntimeError("No assigned parts produced notes. Check assignments and inputs.")

    with warnings.catch_warnings():
        _suppress_known_music21_warnings()
        score = score.makeNotation(inPlace=False)
    full_score_path = workdir / f"{sanitize_filename(options.get('title', 'score'))}.musicxml"
    score.write("musicxml", fp=str(full_score_path))
    return {"full_score": str(full_score_path), "parts": transposed_parts, "skipped_parts": skipped_parts}


def render_pdfs(score_data: dict[str, str | dict[str, str]], run_id: str | None = None) -> dict:
    """Render full-score PDF (concert pitch) and transposed part PDFs via MuseScore CLI.

    Args:
        score_data: dict from build_score with keys "full_score" and "parts".

    Returns dict with keys:
        "paths": list of rendered PDF file paths
        "part_report": list of dicts with part status details for QC/manifest
    """
    from music21 import converter

    _ensure_dirs()

    full_score_xml = Path(score_data["full_score"])
    if not full_score_xml.exists():
        raise FileNotFoundError(f"Full score MusicXML not found: {full_score_xml}")

    output_root = OUTPUT_DIR / sanitize_filename(run_id) if run_id else OUTPUT_DIR
    output_root.mkdir(parents=True, exist_ok=True)

    score_pdf = output_root / f"{full_score_xml.stem}_full_score.pdf"
    _run([MUSESCORE_CMD, "-o", str(score_pdf), str(full_score_xml)])
    rendered: list[str] = [str(score_pdf)]
    part_report: list[dict] = []
    for item in score_data.get("skipped_parts", []) if isinstance(score_data, dict) else []:
        if isinstance(item, dict):
            part_report.append(
                {
                    "name": str(item.get("name", "")),
                    "status": "skipped",
                    "reason": str(item.get("reason", "unknown")),
                    "note_count": int(item.get("note_count", 0)),
                }
            )

    for part_name, part_xml_path in score_data["parts"].items():
        part_xml = Path(part_xml_path)
        if not part_xml.exists():
            part_report.append({
                "name": part_name, "status": "skipped",
                "reason": "missing_musicxml", "note_count": 0,
            })
            continue

        with warnings.catch_warnings():
            _suppress_known_music21_warnings()
            parsed_part = converter.parse(str(part_xml))
        note_count = len(list(parsed_part.recurse().notes))

        if note_count == 0:
            part_report.append({
                "name": part_name, "status": "skipped",
                "reason": "no_notes", "note_count": 0,
            })
            continue

        part_pdf = output_root / f"{sanitize_filename(part_name)}.pdf"
        _run([MUSESCORE_CMD, "-o", str(part_pdf), str(part_xml)])
        rendered.append(str(part_pdf))
        part_report.append({
            "name": part_name, "status": "exported",
            "note_count": note_count, "path": str(part_pdf),
        })

    if len(rendered) == 1:
        raise RuntimeError("No non-empty parts were rendered.")
    return {"paths": rendered, "part_report": part_report}
