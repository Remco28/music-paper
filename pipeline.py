"""Core audio -> score pipeline for BTT MVP."""

from __future__ import annotations

import glob
import shlex
import subprocess
from pathlib import Path
from urllib.parse import parse_qs, urlparse

from pydub import AudioSegment

from config import (
    DEMUCS_MODEL,
    DOWNLOADS_DIR,
    INSTRUMENT_SPECS,
    MUSESCORE_CMD,
    OUTPUT_DIR,
    TEMP_DIR,
    YOUTUBE_DOMAINS,
)
from utils import create_disclaimer_text, sanitize_filename


def _run(cmd: list[str]) -> None:
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        rendered = " ".join(shlex.quote(part) for part in cmd)
        raise RuntimeError(
            f"Command failed ({result.returncode}): {rendered}\n{result.stderr.strip()}"
        )


def _ensure_dirs() -> None:
    TEMP_DIR.mkdir(parents=True, exist_ok=True)
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    DOWNLOADS_DIR.mkdir(parents=True, exist_ok=True)


def _is_youtube_url(source: str) -> bool:
    try:
        parsed = urlparse(source)
    except ValueError:
        return False
    host = parsed.netloc.lower()
    return any(domain in host for domain in YOUTUBE_DOMAINS)


def _validate_single_video_url(source: str) -> None:
    parsed = urlparse(source)
    query = parse_qs(parsed.query)
    if "list" in query:
        raise ValueError("Playlists are not supported. Please provide a single-video URL.")


def download_or_convert_audio(source: str, run_dir: Path | None = None) -> str:
    """Convert local audio file or YouTube URL into normalized wav."""
    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    workdir.mkdir(parents=True, exist_ok=True)
    source = source.strip()
    output_wav = workdir / "input_normalized.wav"

    if _is_youtube_url(source):
        _validate_single_video_url(source)
        yt_template = str(workdir / "youtube_input.%(ext)s")
        _run(
            [
                "yt-dlp",
                "--no-playlist",
                "-x",
                "--audio-format",
                "wav",
                "-o",
                yt_template,
                source,
            ]
        )
        yt_files = sorted(glob.glob(str(workdir / "youtube_input.*")))
        if not yt_files:
            raise RuntimeError("yt-dlp did not produce an audio file.")
        audio = AudioSegment.from_file(yt_files[0])
    else:
        input_path = Path(source)
        if not input_path.exists():
            raise FileNotFoundError(f"Audio source does not exist: {source}")
        audio = AudioSegment.from_file(str(input_path))

    audio = audio.set_channels(2).set_frame_rate(44100)
    audio.export(str(output_wav), format="wav")
    return str(output_wav)


def separate_stems(wav_path: str, run_dir: Path | None = None) -> dict[str, str]:
    """Run Demucs separation and return stem-name -> wav path."""
    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    wav = Path(wav_path)
    if not wav.exists():
        raise FileNotFoundError(f"Input wav missing: {wav_path}")

    demucs_out = workdir / "demucs"
    _run(["demucs", "-n", DEMUCS_MODEL, "-o", str(demucs_out), str(wav)])

    stem_root = demucs_out / DEMUCS_MODEL / wav.stem
    if not stem_root.exists():
        raise RuntimeError(f"Demucs output folder missing: {stem_root}")

    stems: dict[str, str] = {}
    for stem_file in sorted(stem_root.glob("*.wav")):
        stems[stem_file.stem] = str(stem_file)
    if not stems:
        raise RuntimeError("No stems were generated by Demucs.")
    return stems


def transcribe_to_midi(stems: dict[str, str], run_dir: Path | None = None) -> dict[str, str]:
    """Run basic-pitch CLI on each stem file and return stem-name -> midi path."""
    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    midi_root = workdir / "midi"
    midi_root.mkdir(parents=True, exist_ok=True)

    outputs: dict[str, str] = {}
    for stem_name, stem_path in stems.items():
        stem_dir = midi_root / sanitize_filename(stem_name)
        stem_dir.mkdir(parents=True, exist_ok=True)
        _run(["basic-pitch", str(stem_dir), str(stem_path)])
        midi_candidates = sorted(stem_dir.glob("*.mid")) + sorted(stem_dir.glob("*.midi"))
        if not midi_candidates:
            raise RuntimeError(f"No MIDI produced for stem: {stem_name}")
        outputs[stem_name] = str(midi_candidates[0])
    return outputs


def _grid_to_divisor(grid: str) -> int:
    mapping = {"1/4": 1, "1/8": 2, "1/16": 4}
    return mapping.get(grid, 2)


def _simplify_part(part_stream, options: dict) -> None:
    divisor = _grid_to_divisor(options.get("quantize_grid", "1/8"))
    min_duration = float(options.get("min_note_duration_beats", 0.25))
    density_threshold = int(options.get("density_threshold", 6))

    part_stream.quantize(
        quarterLengthDivisors=(divisor,),
        processOffsets=True,
        processDurations=True,
        inPlace=True,
    )

    flattened = part_stream.flatten()
    bucket_counts: dict[int, int] = {}
    for element in list(flattened.notesAndRests):
        if getattr(element, "isNote", False) or getattr(element, "isChord", False):
            if float(element.duration.quarterLength) < min_duration:
                element.activeSite.remove(element)
                continue
            bucket = int(float(element.offset))
            bucket_counts[bucket] = bucket_counts.get(bucket, 0) + 1
            if bucket_counts[bucket] > density_threshold:
                element.activeSite.remove(element)


def build_score(
    midis: dict[str, str], assignment: dict[str, str], options: dict,
    run_dir: Path | None = None,
) -> dict[str, str | dict[str, str]]:
    """Build concert-pitch full score and transposed individual part MusicXML files.

    Returns dict with keys:
        "full_score": path to concert-pitch MusicXML
        "parts": dict mapping part_name -> transposed part MusicXML path
    """
    import copy

    from music21 import converter, expressions, interval, metadata, stream

    _ensure_dirs()
    workdir = run_dir or TEMP_DIR
    score = stream.Score(id="btt-score")
    score.metadata = metadata.Metadata()
    score.metadata.title = options.get("title", "Untitled")
    score.metadata.composer = options.get("composer", "")

    disclaimer = create_disclaimer_text(options.get("school", ""))
    simplify_enabled = bool(options.get("simplify_enabled", False))

    part_dir = workdir / "part_exports"
    part_dir.mkdir(parents=True, exist_ok=True)
    transposed_parts: dict[str, str] = {}
    instrument_counts: dict[str, int] = {}

    for stem_name, midi_path in midis.items():
        instrument_name = assignment.get(stem_name, "").strip()
        if not instrument_name:
            continue

        # Disambiguate when multiple stems share the same instrument
        instrument_counts[instrument_name] = instrument_counts.get(instrument_name, 0) + 1
        count = instrument_counts[instrument_name]
        part_label = instrument_name if count == 1 else f"{instrument_name} ({count})"

        parsed = converter.parse(midi_path)
        part_stream = parsed.parts[0] if parsed.parts else parsed
        part_stream.partName = part_label
        part_stream.partAbbreviation = part_label

        if simplify_enabled:
            _simplify_part(part_stream, options)

        # Concert-pitch copy for the full score
        concert_part = copy.deepcopy(part_stream)
        concert_part.insert(0, expressions.TextExpression(disclaimer))
        score.insert(0, concert_part)

        # Transposed copy for the individual part export
        semitones = int(INSTRUMENT_SPECS.get(instrument_name, 0))
        transposed_part = copy.deepcopy(part_stream)
        if semitones:
            transposed_part.transpose(interval.Interval(semitones), inPlace=True)
        transposed_part.insert(0, expressions.TextExpression(disclaimer))

        part_xml = part_dir / f"{sanitize_filename(part_label)}.musicxml"
        transposed_part.write("musicxml", fp=str(part_xml))
        transposed_parts[part_label] = str(part_xml)

    if not score.parts:
        raise RuntimeError("No assigned parts produced notes. Check assignments and inputs.")

    full_score_path = workdir / f"{sanitize_filename(options.get('title', 'score'))}.musicxml"
    score.write("musicxml", fp=str(full_score_path))
    return {"full_score": str(full_score_path), "parts": transposed_parts}


def render_pdfs(score_data: dict[str, str | dict[str, str]]) -> dict:
    """Render full-score PDF (concert pitch) and transposed part PDFs via MuseScore CLI.

    Args:
        score_data: dict from build_score with keys "full_score" and "parts".

    Returns dict with keys:
        "paths": list of rendered PDF file paths
        "part_report": list of dicts with part status details for QC/manifest
    """
    from music21 import converter

    _ensure_dirs()

    full_score_xml = Path(score_data["full_score"])
    if not full_score_xml.exists():
        raise FileNotFoundError(f"Full score MusicXML not found: {full_score_xml}")

    score_pdf = OUTPUT_DIR / f"{full_score_xml.stem}_full_score.pdf"
    _run([MUSESCORE_CMD, "-o", str(score_pdf), str(full_score_xml)])
    rendered: list[str] = [str(score_pdf)]
    part_report: list[dict] = []

    for part_name, part_xml_path in score_data["parts"].items():
        part_xml = Path(part_xml_path)
        if not part_xml.exists():
            part_report.append({
                "name": part_name, "status": "skipped",
                "reason": "MusicXML file missing", "note_count": 0,
            })
            continue

        parsed_part = converter.parse(str(part_xml))
        note_count = len(list(parsed_part.recurse().notes))

        if note_count == 0:
            part_report.append({
                "name": part_name, "status": "skipped",
                "reason": "empty (no notes)", "note_count": 0,
            })
            continue

        part_pdf = OUTPUT_DIR / f"{sanitize_filename(part_name)}.pdf"
        _run([MUSESCORE_CMD, "-o", str(part_pdf), str(part_xml)])
        rendered.append(str(part_pdf))
        part_report.append({
            "name": part_name, "status": "exported",
            "note_count": note_count, "path": str(part_pdf),
        })

    if len(rendered) == 1:
        raise RuntimeError("No non-empty parts were rendered.")
    return {"paths": rendered, "part_report": part_report}
